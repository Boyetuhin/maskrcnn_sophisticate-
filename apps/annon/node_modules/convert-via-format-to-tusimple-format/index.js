if(typeof(exports) == 'undefined') { exports = {}; }

const fs = require('fs');
const path = require("path");
const mkdirp = require("mkdirp");
var cla = require('command-line-args');
var clu = require('command-line-usage');
let {Point, circle, Segment} = require('flatten-js');
var workDir = "/tmp/"+(process.env.USER || 'default')+"/";
mkdirp.sync(workDir);
var readlineSync = require('readline-sync');


exports._convertViaToTuSimple = function() {
  this.init();
}

exports._convertViaToTuSimple.prototype.getOpts = function () {
  var optDefs = [
    { name: 'inFile', type: String, multiple: true, defaultOption: true }
    ,{ name: 'outFile', type: String }
    ,{ name: 'outDir', type: String }
    ,{ name: 'pred', type: Boolean }
    ,{ name: 'hLine', type: Boolean }  // horizontal line rod type
    ,{ name: 'short', type: Boolean }
  ];
  this.debug = true;
  var opts = cla(optDefs);
  return opts
}

exports._convertViaToTuSimple.prototype.init = function () {
  var opts = this.getOpts();
  console.log({opts});
  if (!opts.inFile || !opts.inFile.length) {
    console.log("in file please ..");
    process.exit();
  }
  var logFile = workDir+path.basename(__filename)+".log";
  this.logS = fs.openSync(logFile,"w");
  this.printBoth("Log file at ",logFile);
  for (var one of opts.inFile) {
    if (!fs.existsSync(one)) { console.log("File Absent ",one); continue; }
    var xOrY = 'x';
    if (opts.hLine) { xOrY = 'y'; }
    this.convertOneFile(opts,one,xOrY);
  }
}

exports._convertViaToTuSimple.prototype.getSegments = function (sax,say,obj) {
  if (sax.length != say.length) {
    this.printBoth("Error: x y dont match ",obj);
  }
  var setA = [];
  var last = null;
  for (var i=0; i<Math.min(sax.length,say.length); i++) {
    var pt = new Point(sax[i]*2/3,say[i]*2/3);
    if (!last) { last = pt; continue; }
    setA.push(new Segment(last,pt));
    last = pt;
  }
  return setA;
}

exports._convertViaToTuSimple.prototype.getCutPoints = function (refSeg,setA,xOrY,obj,errors) {
  var lp = [];
  for (var oneRef of refSeg) {
    var isect = [];
    for (var oneSeg of setA) {
      var t = oneSeg.intersect(oneRef);
      if (!t.length) { continue; }
      if (t.length > 1) { 
        this.printLog("Error multiple seg cut ",Object.assign({},obj,{oneSeg,oneRef})); 
        var err = "Error multiple seg cut "+obj.image+" idx "+obj.idx;
        errors[err] = 1;
        continue; 
      }
      isect.push(t[0]);
    }
    if (!isect.length) { lp.push(-2); continue; }
    if (isect.length == 2 && 
        Math.round(isect[0][xOrY]) == Math.round(isect[1][xOrY])) {
      isect.pop();
    }
    if (isect.length > 1) { 
      this.printLog("Error multiple lane cut ",Object.assign({},obj,{setA,oneRef,isect})); 
      var err = "Error multiple lane cut "+obj.image+" idx "+obj.idx;
      errors[err] = 1;
      lp.push(-2);
      continue; 
    }
    lp.push(Math.round(isect[0][xOrY]));
  }
  return lp;
}

exports._convertViaToTuSimple.prototype.getLaneHash = function (opts,anno,refSeg,xOrY) {
  var lanesH = {};
  var errors = {};
  var xOrY = xOrY || 'x';
  var ri = 0;
  for (var one of anno.regions) { 
    ri++;
    if (xOrY == 'y') { var idx = ri; } else {
      var idx = one.region_attributes.Label || ri; 
    }
    var printObj = {image:anno.filename,label:idx,idx:ri,one};
    if (one.shape_attributes.name != 'polyline') {
      this.printBoth("Error: Only polylines are allowed ",printObj);
      continue;
    }

    var setA = this.getSegments(
      one.shape_attributes.all_points_x
      ,one.shape_attributes.all_points_y
      ,printObj
    );
    //this.printLog({setA});

    var lp = this.getCutPoints(refSeg,setA,xOrY
      ,printObj
      ,errors
    );
    //this.printLog({lp});

    lanesH[idx] = lp;
  }
  if (Object.keys(errors).length) {
    this.printBoth(Object.keys(errors));
    this.printBoth("This annotation will be ignored");
    lanesH = {};
  }
  return lanesH;
}


exports._convertViaToTuSimple.prototype.doPredictionFormatting = function (opts,annoA,refSeg,blankLane) {
  if (Array.isArray(annoA)) { } else { annoA = [annoA]; }
  var errors = {};
  var ret = [];
  for (var anno of annoA) {
    if (!anno.x_axis) {
      var err = "Error x_axis not found (Check your file) "+anno.image_name;
      errors[err] = 1; 
      continue;
    }
    if (!anno.y_axis) { 
      var err = "Error y_axis not found (Check your file) "+anno.image_name;
      errors[err] = 1; 
      continue;
    }
    if (anno.y_axis.length != anno.x_axis.length) { 
      var err = "No of lanes in x_axis and y_axis different"+anno.image_name;
      errors[err] = 1; 
      continue;
    }
    var lanesH = {};
    for (var i=0; i<Math.min(anno.x_axis.length,anno.y_axis.length); i++) {
      var sax = anno.x_axis[i];
      var say = anno.y_axis[i];
      if (sax.length != say.length) {
        var err = "Error: x y dont match for index "+anno.image_name+'('+i+')';
        errors[err] = 1; 
        continue;
      }
      var setA = [];
      var last = null;
      for (var j=0; j<Math.min(sax.length,say.length); j++) {
        var pt = new Point(sax[j],say[j]);
        if (!last) { last = pt; continue; }
        setA.push(new Segment(last,pt));
        last = pt;
      }
      this.printLog({setA});
      var lp = [];
      for (var oneRef of refSeg) {
        var isect = [];
        for (var oneSeg of setA) {
          var t = oneSeg.intersect(oneRef);
          if (!t.length) { continue; }
          if (t.length > 1) { 
            this.printLog("Error multiple seg cut ",{image:anno.image_name,idx:i,oneSeg,oneRef}); 
            var err = "Error multiple seg cut "+anno.image_name+" idx "+i;
            errors[err] = 1;
            continue; 
          }
          isect.push(t[0]);
        }
        if (!isect.length) { lp.push(-2); continue; }
        if (isect.length > 1) { 
          this.printLog("initial isect ",isect);
          var isectOut = [];
          isectOut.push(isect[0]);
          var ref1 = Math.round(isect[0].x);
          for (var r = 1;r<isect.length;r++) {
            var ref2 = Math.round(isect[r].x);
            if (ref1 == ref2) { continue; }
            isectOut.push(isect[r]);
            ref1 = Math.round(isect[r].x);
          }
          isect = isectOut;
          this.printLog("final isect ",isect);
        }
        var oneIsect = Math.round(isect[0].x);
        if (isect.length > 1) {
          oneIsect = Math.round(isect.reduce(function (p,c) {
            return p+Math.round(c.x);
          },0)/isect.length);
          this.printLog("Multiple lane cut (averaging it) ",{image:anno.image_name,idx:i,setA,oneRef,isect,oneIsect}); 
          //var err = "Multiple lane cut (averaging it) "+anno.image_name+" idx "+i;
          //errors[err] = 1;
        }
        lp.push(oneIsect);
      }
      var slope = this.getAvgSlope(lp);
      this.printLog("Average slope ",{image:anno.image_name,slope});
      this.printLog({lp});
      this.reorderLanesWithSlope(lanesH,slope,lp);
    }
    this.printLog({lanesH});
    var lanes = [];
    if (Object.keys(lanesH).length) {
      var t = Object.keys(lanesH).reduce(function (p,c) {
        p[c] = lanesH[c].lp; 
        return p;
      },{});
      this.printLog({t});
      lanes = this.getLanes(opts,{filename:anno.image_name},t,blankLane);
    }
    this.printLog({lanes});
    ret.push({image:anno.image_name,lanes});
  }
  if (Object.keys(errors).length) {
    this.printBoth(Object.keys(errors));
  }
  return ret;
}

exports._convertViaToTuSimple.prototype.getAvgSlope = function (lp) {
  //var slopeA = [];
  var t = lp.reduce(function (p,c) {
    if (c == -2) { return p; }
    if (!p.prev) { p.prev = c; return p; }
    var one = Math.round(Math.atan2(10,c-p.prev) * 180/Math.PI);
    // value 10 because of horizontal grid's vertical pixels
    p.prev = c;
    p.sum += one;
    p.cnt++;
    //slopeA.push(one);
    return p;
  },{sum:0,cnt:0});
  var slope = Math.round(t.sum/t.cnt);
  //this.printLog("Average slope ",{image:anno.image_name,slope,slopeA});
  return slope;
}

exports._convertViaToTuSimple.prototype.reorderLanesWithSlope = function (lanesH,slope,lp) {
  if (slope > 90) {
    if (!lanesH[1]) { lanesH[1] = {slope,lp}; }
    else {
      if (lanesH[1].slope < slope) {
        lanesH[3] = {slope,lp};
      } else {
        lanesH[3] = lanesH[1];
        lanesH[1] = {slope,lp};
      }
    }
  } else {
    if (!lanesH[2]) { lanesH[2] = {slope,lp}; }
    else {
      if (lanesH[2].slope > slope) {
        lanesH[4] = {slope,lp};
      } else {
        lanesH[4] = lanesH[2];
        lanesH[2] = {slope,lp};
      }
    }
  }
}

exports._convertViaToTuSimple.prototype.getHLines = function (opts,anno,lanesH,blankLane) {
  var lanes = [];
  for (var k in lanesH) {
    var one = lanesH[k];
    var count = 0;
    var sum = one.reduce(function (p,c) {
      if (c == -2) { return p; }
      count++;
      return p+c;
    },0);
    var avg = count? sum/count : 0;
    lanes.push({avg,one});
  }
  lanes.sort(function (a,b) {
    return a.avg-b.avg;
  });
  return lanes.map(x=>x.one);
}

exports._convertViaToTuSimple.prototype.getLanes = function (opts,anno,lanesH,blankLane) {
  var lanes = [];
  if (lanesH.leftborder || lanesH.rightborder) {
    //delete lanesH.leftborder;
    //delete lanesH.rightborder;
    var oneLane = {};
    if (!lanesH[1]) {  // no one
      this.printLog({type:1,lanesH});
      lanes = lanes.concat([
        lanesH.leftboundry || lanesH.leftboundary || JSON.parse(JSON.stringify(blankLane)) // why
        ,lanesH[2] || JSON.parse(JSON.stringify(blankLane))
        ,lanesH[3] || JSON.parse(JSON.stringify(blankLane))
        ,lanesH.rightboundry || lanesH.rightborder || JSON.parse(JSON.stringify(blankLane))
      ]);
    } else if (lanesH[1]) {  // no three
      lanes = lanes.concat([
        lanesH[1]
        ,lanesH[2] || JSON.parse(JSON.stringify(blankLane))
        ,lanesH.leftboundry || lanesH.leftboundary || JSON.parse(JSON.stringify(blankLane)) // why
        ,lanesH.rightboundry || lanesH.rightborder || JSON.parse(JSON.stringify(blankLane))
      ]);
    } else {
      this.printLog({type:'unknown',lanesH});
      this.printLog("Consult navada@vidteq.com for this problem ");
      process.exit();
    }
  } else if (lanesH.leftboundry || lanesH.rightboundry) {
    for (var i of ['leftboundry','rightboundry',3,4]) { // 3,4 TBD
      if (lanesH[i]) {
        lanes.push(lanesH[i]);
      } else {
        lanes.push(JSON.parse(JSON.stringify(blankLane)));
      }
    }
  } else if (lanesH[1] || lanesH[2] || lanesH[3] || lanesH[4]) {
    var refOrder = [1,2,3,4,5,6,7,8];
    if (opts.short) { refOrder = [1,2,3,4]; }
    for (var i of refOrder) {
      if (lanesH[i]) {
        lanes.push(lanesH[i]);
      } else {
        lanes.push(JSON.parse(JSON.stringify(blankLane)));
      }
    }
  }
  if (!lanes.length) {
    if (lanesH.TBD) { return lanes; } // for now it is ok TBD
    this.printBoth("Error no proper labels found ",{image:anno.filename});
  }
  return lanes;
}

exports._convertViaToTuSimple.prototype.readInFile = function (opts,inFile) {
  var read = fs.readFileSync(inFile);
  var anno = null;
  try {
    anno = JSON.parse(read);
  } catch (e) {
    this.printBoth("Non Json format ");
    var readA = read.toString().split(/\n/);
    anno = [];
    var err = readA.filter(function (one) {
      var ret;
      if (one.toString().match(/^\s*$/)) { return false; }
      try { ret = JSON.parse(one); } catch (e) { return true; }
      anno.push(ret);
      return false;
    });
    if (err.length) {
      this.printLog("Error found in parsing ",err);
      this.printBoth("Error found, see log ",err.length);
    }
  }
  return anno;
}

exports._convertViaToTuSimple.prototype.checkOutFile = function (opts,outFile,xOrY) {
  this.printBoth("Checking the out file ",outFile);
  var read = fs.readFileSync(outFile);
  var anno = null;
  try {
    anno = JSON.parse(read);
  } catch (e) {
    //this.printBoth("Non Json format outfile ");
    var readA = read.toString().split(/\n/);
    anno = [];
    var err = readA.filter(function (one) {
      var ret;
      if (one.toString().match(/^\s*$/)) { return false; }
      try { ret = JSON.parse(one); } catch (e) { return true; }
      anno.push(ret);
      return false;
    });
    if (err.length) {
      this.printLog("Error found in parsing ",err);
      this.printBoth("Error found, see log ",err.length);
    }
  }
  var err = [];
  for (var one of anno) {
    if (!one.lanes || !(one.h_samples || one.v_samples) || !one.raw_file) {
      err.push("Improper fields in "+one.raw_file);
      continue;
    }
    for (var i in one.lanes) {
      if (one.lanes[i].length != (one.h_samples || one.v_samples).length) {
        err.push("Lane idx "+i+" length does not match with (h/v)_samples length in "+one.raw_file);
      }
    }
  }
  if (err.length) {
    this.printLog("Error found in parsing outfile ",err);
    this.printBoth("Error found, see log ",err.length);
  } else {
    this.printBoth("Outfile ok");
  }
  return anno;
}

exports._convertViaToTuSimple.prototype.doViaFormatting = function (opts,anno,refSeg,blankLane,xOrY) {
  var count = 0;
  var retLanes = [];
  for (var key in anno) {
    if (!anno[key].regions) { continue; }
    count++;
    var lanesH = this.getLaneHash(opts,anno[key],refSeg,xOrY);
    this.printLog({lanesH});
    if (!Object.keys(lanesH).length) { continue; }
    if (xOrY == 'x') {
      var lanes = this.getLanes(opts,anno[key],lanesH,blankLane);
    }
    if (xOrY == 'y') {
      var lanes = this.getHLines(opts,anno[key],lanesH,blankLane);
    }
    if (!lanes.length) { continue; }
    retLanes.push({lanes,image:anno[key].filename});
  }
  if (!count) {
    this.printBoth("No regions found in the file (please check)");
  }
  return retLanes;
}

exports._convertViaToTuSimple.prototype.fillOutRec = function (outRec,key,val) {
  if (!(key in outRec)) {
    outRec[key] = {};
  }
  if (!(val in outRec[key])) {
    outRec[key][val] = 0;
  }
  //outRec[key][val]++;
  outRec[key][val]++;
} 

exports._convertViaToTuSimple.prototype.getOneCollapse = function (one,all) {
  this.printLog("one is ",one);
  var oneOut = {};
  oneOut.all = {};
  var outAll = oneOut.all;
  outAll.imageCount = 0;
  outAll.annoImgCnt = 0;
  outAll.imgPerCat = {};
  outAll.fileAttr = {};
  for (var id in one) {
    var oneV = one[id];
    outAll.imageCount++;
    all.imageCount++;
    oneOut[id] = {};
    var outRec = oneOut[id];
    var images = oneV.filename;
    this.printLog("images ",images);
    var img = [];
    img.push(images);
    this.printLog("img ",img);
    oneOut.img = img;
    if ('regions' in oneV && oneV.regions.length) {
      all.annoImgCnt++;
      outAll.annoImgCnt++;
    }
    for (var oneImg of img) {
      var regions = oneV.regions;
      this.printLog("regions ",regions);
      for (var oneRegion of regions) {
        var ra = oneRegion.region_attributes;
        //ra["image"] = image;
        //self::debugMsg("ra value is ".print_r(ra,true)."\n");
        for (var key in ra) {
          var raVal = ra[key];
          if (typeof raVal == 'object') {
            var c = Object.keys(raVal).length;
            if (!c) { continue; }
            var val = 'idontknow';
            if (c == 1 && 'yes' in raVal) {
              // only case for now
              val = 'yes';
            }
            this.fillOutRec(outRec,key,val);
            this.fillOutRec(outAll,key,val);
            this.fillOutRec(all,key,val);
          } else {
            this.fillOutRec(outRec,key,raVal);
            this.fillOutRec(outAll,key,raVal);
            this.fillOutRec(all,key,raVal);
          }
        }
      }
    }
    //foreach (outRec as key => val) {
    //  foreach (val as key1 => val1) {
    //    self::fillOutRec(all['imgPerCat'],key,key1);
    //    self::fillOutRec(outAll['imgPerCat'],key,key1);
    //  }
    //}
    if (oneV.file_attributes) {
      for (var key in oneV.file_attributes) {
        this.fillOutRec(all.fileAttr,key,oneV.file_attributes[key]);
        this.fillOutRec(outAll.fileAttr,key,oneV.file_attributes[key]);
      }
    }
  }
  return oneOut;
}

exports._convertViaToTuSimple.prototype.filter = function (opts,anno) {
  var ret = {};
  for (var k in anno) {
    var filt = false; 
    var one = anno[k];
    if (one.regions.length) {
      for (var r of one.regions) {
        if (r.region_attributes &&
            r.region_attributes.LanePos &&
            (r.region_attributes.LanePos == "sol" ||
            r.region_attributes.LanePos == "nrv")) {
          filt = true;
        }
      }
    }
    if (one.file_attributes && 
        one.file_attributes.junction_type &&
        (one.file_attributes.junction_type == 'JN_Ahead' ||
        one.file_attributes.junction_type == 'On_JN' ||
        one.file_attributes.junction_type == 'Corner_Case')) {
      filt = true;
    }
    if (!filt) { ret[k] = one; }
  }
  return ret;
}

exports._convertViaToTuSimple.prototype.getSamples = function (xOrY,h,w) {
  var samples = [];
  if (xOrY == 'y') { 
    for (var i = 10;i<w;i+=10) {
      samples.push(i);
    }
  }
  if (xOrY == 'x') { 
    samples = [160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 280, 290, 300, 310, 320, 330, 340, 350, 360, 370, 380, 390, 400, 410, 420, 430, 440, 450, 460, 470, 480, 490, 500, 510, 520, 530, 540, 550, 560, 570, 580, 590, 600, 610, 620, 630, 640, 650, 660, 670, 680, 690, 700, 710];
  }
  var refSeg = [];
  var blankLane = [];
  if (xOrY == 'y') { 
    for (var x of samples) {
      refSeg.push(new Segment(new Point(x,0),new Point(x,h-1)));
      blankLane.push(-2);
    }
  }
  if (xOrY == 'x') { 
    for (var y of samples) {
      refSeg.push(new Segment(new Point(0,y),new Point(w-1,y)));
      blankLane.push(-2);
    }
  }
  return {samples,refSeg,blankLane};
}

exports._convertViaToTuSimple.prototype.convertOneFile = function (opts,inFile,xOrY) {
  if (!fs.existsSync(inFile) || !fs.statSync(inFile).isFile()) {
    this.printBoth("Not a file ",inFile);
    return false;
  }
  var anno = this.readInFile(opts,inFile);
  this.printLog({anno});
  if (!anno) { // || !anno.length && !Object.keys(anno).length) { //}
    this.printBoth("Nothing to do in ",inFile);
    return false; 
  }
  if (opts.pred) { } else {
    // filtering
    var all = {imageCount:0,annoImgCnt:0,imgPerCat:{},fileAttr:{}};
    this.getOneCollapse(anno,all);
    this.printBoth({all});
    this.printBoth({fileAttr:all.fileAttr});
    var yOrN = readlineSync.question('May I filter? ');
    var all = {imageCount:0,annoImgCnt:0,imgPerCat:{},fileAttr:{}};
    var anno = this.filter(opts,anno);
    this.getOneCollapse(anno,all);
    this.printBoth({all});
    this.printBoth({fileAttr:all.fileAttr});
    var yOrN = readlineSync.question('May I proceed? ');
  }

  var outFile = inFile.replace(/\.json/,'_tuSimple.json');
  if (opts.outFile) { outFile = opts.outFile; }
  if (opts.outDir) { 
    mkdirp.sync(opts.outDir);
    outFile = opts.outDir+"/"+path.basename(outFile);
  }
  var fOut = fs.openSync(outFile,'w');
  var {samples,refSeg,blankLane} = this.getSamples(xOrY,720,1280);
  var sKey = 'h_samples';
  if (xOrY == 'y') { sKey = 'v_samples'; }
  if (opts.pred) {
    var lanes = this.doPredictionFormatting(opts,anno,refSeg,blankLane);
    for (var lane of lanes) {
      var oneOut = {lanes:lane.lanes,raw_file:lane.image};
      oneOut[sKey] = samples;
      fs.writeSync(fOut,JSON.stringify(oneOut)+'\n');
    }
  } else {
    var lanes = this.doViaFormatting(opts,anno,refSeg,blankLane,xOrY);
    for (var lane of lanes) {
      var oneOut = {lanes:lane.lanes,raw_file:lane.image};
      oneOut[sKey] = samples;
      fs.writeSync(fOut,JSON.stringify(oneOut)+'\n');
    }
  }
  fs.close(fOut); 
  this.printBoth("Out file at ",outFile);
  this.checkOutFile(opts,outFile,xOrY); 
}

//exports._convertViaToTuSimple.prototype.convertOneFile = function (opts,inFile) {
//  if (!fs.existsSync(inFile) || !fs.statSync(inFile).isFile()) {
//    this.printBoth("Not a file ",inFile);
//    return false;
//  }
//  var anno = this.readInFile(opts,inFile);
//  this.printLog({anno});
//  if (!anno) { // || !anno.length && !Object.keys(anno).length) { //}
//    this.printBoth("Nothing to do in ",inFile);
//    return false; 
//  }
//  if (opts.pred) { } else {
//    // filtering
//    var all = {imageCount:0,annoImgCnt:0,imgPerCat:{},fileAttr:{}};
//    this.getOneCollapse(anno,all);
//    this.printBoth({all});
//    this.printBoth({fileAttr:all.fileAttr});
//    var yOrN = readlineSync.question('May I filter? ');
//    var all = {imageCount:0,annoImgCnt:0,imgPerCat:{},fileAttr:{}};
//    var anno = this.filter(opts,anno);
//    this.getOneCollapse(anno,all);
//    this.printBoth({all});
//    this.printBoth({fileAttr:all.fileAttr});
//    var yOrN = readlineSync.question('May I proceed? ');
//  }
//
//  var outFile = inFile.replace(/\.json/,'_tuSimple.json');
//  if (opts.outFile) { outFile = opts.outFile; }
//  if (opts.outDir) { 
//    mkdirp.sync(opts.outDir);
//    outFile = opts.outDir+"/"+path.basename(outFile);
//  }
//  var fOut = fs.openSync(outFile,'w');
//  var h_samples = [160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 280, 290, 300, 310, 320, 330, 340, 350, 360, 370, 380, 390, 400, 410, 420, 430, 440, 450, 460, 470, 480, 490, 500, 510, 520, 530, 540, 550, 560, 570, 580, 590, 600, 610, 620, 630, 640, 650, 660, 670, 680, 690, 700, 710];
//  var refSeg = [];
//  var blankLane = [];
//  for (var y of h_samples) {
//    refSeg.push(new Segment(new Point(0,y),new Point(1279,y)));
//    blankLane.push(-2);
//  }
//  if (opts.pred) {
//    var lanes = this.doPredictionFormatting(opts,anno,refSeg,blankLane);
//    for (var lane of lanes) {
//      var oneOut = {lanes:lane.lanes,h_samples,raw_file:lane.image};
//      fs.writeSync(fOut,JSON.stringify(oneOut)+'\n');
//    }
//  } else {
//    var lanes = this.doViaFormatting(opts,anno,refSeg,blankLane);
//    for (var lane of lanes) {
//      var oneOut = {lanes:lane.lanes,h_samples,raw_file:lane.image};
//      fs.writeSync(fOut,JSON.stringify(oneOut)+'\n');
//    }
//  }
//  fs.close(fOut); 
//  this.printBoth("Out file at ",outFile);
//  this.checkOutFile(opts,outFile); 
//}

exports._convertViaToTuSimple.prototype.printLog = function () {
  if (this.logS) {} else { return; }
  for (var i of arguments) {
    if (typeof(i) == 'object') {
      fs.writeSync(this.logS,JSON.stringify(i,null,2)+' ');
      continue;
    }
    fs.writeSync(this.logS,i+' ');
  }
  fs.writeSync(this.logS,"\n");
}

exports._convertViaToTuSimple.prototype.printBoth = function () {
  this.printLog.apply(this,arguments);
  console.log.apply(this,arguments);
}


if (typeof module !== 'undefined') {
  module.exports = exports._convertViaToTuSimple;
} else {
  exports.convertViaToTuSimple = new exports._convertViaToTuSimple();
}
